const markov = {
    /**
     * Generates a markov chain model object based on an array of text.
     * @param {array} corpus - An array of strings (sentences) that will be used to generate the text
     * @param {object} options - Options
     */
    generateModel: (corpus = [], options = {}) => {
        // Default options
        const modelOptions = {
            // Whether or not to consider case when building the model
            isCaseSensitive: false,
            // How many words on each state
            stateSize: 2,
            // Regex with characters to be ignored
            regex: "[\u2000-\u206F\u2E00-\u2E7F\\\'!\"#$%&()*+,\-.\/:;<=>?@\[\]^_`{|}~]",
            // TODO
            // spellcheck
            ...options
        }

        // Check for valid option parameters
        if (
            typeof modelOptions.isCaseSensitive !== "boolean" ||
            (Number.isInteger(modelOptions.stateSize) && modelOptions.stateSize > 0) !== true) {
            throw new Error("Invalid options.")
        }

        try {
            modelOptions.regex = new RegExp(modelOptions.regex, "ig")
        } catch {
            throw new Error("Invalid options.")
        }

        const model = { starts: [0, {}], states: {} }

        corpus.forEach(sentence => {
            // Check for valid input
            if (typeof sentence !== "string") throw new Error("Invalid item in corpus.")

            // Apply lowercase if it's necessary
            if (!modelOptions.isCaseSensitive) sentence = sentence.toLowerCase()

            // Process the sentence
            const textArray = markov.processSentence(sentence)

            // Return if the array isn't long enough
            if (textArray.length < modelOptions.stateSize) return

            // Loop over the text array
            for (let i = 0; i < textArray.length; i++) {

                // Generate the current state based on the state size
                // .fill("") is there because .map() doesn't work on arrays generated by
                // the constructor, as their indexes are empty (not underfined or null, just empty)
                // lol
                const currentStateArr = new Array(modelOptions.stateSize).fill("").reduce((acc, curr, index) => {
                    // Replace each element with it's respective word in the sentence,
                    // or stop if the sentence ends
                    return textArray[index + i] ? acc.concat([textArray[index + i]]) : acc
                }, [])

                // If current state is smaller than the state size, return
                if (currentStateArr.length < modelOptions.stateSize) return

                // Convert the state into string
                const currentState = currentStateArr.join(" ")

                // If necessary add state to possible starts
                if (i === 0) {
                    if (!model.starts[1][currentState]) {
                        model.starts[1][currentState] = 0
                    }
                    model.starts[0] += 1
                    model.starts[1][currentState] += 1
                }

                // Add the state to the chain if it's new
                if (!model.states[currentState]) {
                    // 0 -> Number of continuations processed
                    // {} -> Continuations and their totals
                    model.states[currentState] = [0, {}]
                }

                // Increase the number of continuations of the state
                model.states[currentState][0] += 1

                // Check the continuation to the current state
                const continuation = textArray[modelOptions.stateSize + i] ? textArray[modelOptions.stateSize + i] : ""
                if (!model.states[currentState][1][continuation]) {
                    model.states[currentState][1][continuation] = 0
                }
                model.states[currentState][1][continuation] += 1
            }

        })

        // Return the model
        return model
    },
    /**
     * Processes a sentence in order for it to be usable in model generation
     * @param {string} sentence - The sentence to be processed
     * @returns 
     */
    processSentence: (sentence, regex) => {
        // Remove the regex
        sentence = sentence.replace(regex, " ").replace(/\s{2,}/g, " ")

        return sentence.split(" ")
    },
    /**
     * Gets a random option from the state, using the weighted values.
     * @param {object} state - The state to use
     */
    getRandomOptionFromState: (state) => {
        const rnd = Math.floor(Math.random() * state[0])
        let cumulative = 0
        // Iterate through the probabilities 
        for (possibility of Object.entries(state[1])) {
            const prob = possibility[1]
            if (rnd >= cumulative && rnd < cumulative + prob) {
                return possibility[0]
            } else {
                cumulative += prob
            }
        }
    },
    /**
     * Generates a phrase from the markov chain model object
     * @param {object} model - The model object
     */
    generateTextFromModel: (model) => {
        // Start out the generated phrase with one of the starting options
        const phraseArray = markov.getRandomOptionFromState(model.starts).split(' ')
        const stateSize = phraseArray.length

        while (true) {
            // Check the state formed by the last stateSize words of the phrase
            const currentState = phraseArray.reduce((acc, curr, index) => {
                if (phraseArray.length - index <= stateSize) {
                    const newAcc = [...acc, curr]
                    return newAcc
                }
                return acc
            }, []).join(' ')
            // If there are none, end the phrase
            if (!model.states[currentState]) {
                break
            }
            // Otherwise, randomly select the next word using the weights in the branch
            const nextWord = markov.getRandomOptionFromState(model.states[currentState])
            // If it's an empty string, end the phrase
            if (!nextWord) break
            // Otherwise add the word to the phrase
            phraseArray.push(nextWord)
        }
        // Return the phrase with proper formatting
        const phrase = phraseArray.join(' ')
        return phrase
    },
    /**
     * Merges 2 models together
     * @param {object} modelA - First model
     * @param {object} modelB - Second model
     */
    mergeModels(modelA, modelB) {
        // {
        //     starts: [num, {words:num}]
        //     states: {words: [num, {word:num}]}
        // }

        const newModel = { starts: [0, {}], states: {} }
        // First, merge the starts
        newModel.starts[0] = modelA.starts[0] + modelB.starts[0]
        const startsList = Object.entries(modelA.starts[1]).concat(Object.entries(modelB.starts[1]))
        // [words, num]
        startsList.forEach(s => {
            if (!newModel.starts[1][s[0]]) {
                newModel.starts[1][s[0]] = 0
            }
            newModel.starts[1][s[0]] += s[1]
        })
        // Then the states
        const stateList = Object.entries(modelA.states).concat(Object.entries(modelB.states))
        // [words, [num, {word:num}]]
        stateList.forEach(s => {
            const stateName = s[0]
            const state = s[1]
            if (!newModel.states[stateName]) {
                newModel.states[stateName] = [0, {}]
            }
            newModel.states[stateName][0] += state[0]
            for (const word in state[1]) {
                if (!newModel.states[stateName][1][word]) {
                    newModel.states[stateName][1][word] = 0
                }
                newModel.states[stateName][1][word] += state[1][word]
            }
        })

        return newModel
    },
    /**
     * Updates an existing model
     * @param {object} model - The model to be updated
     * @param {array} corpus - The new corpus
     */
    updateModel(model, corpus) {
        // First, create new model from new corpus
        const newModel = markov.generateModel(corpus)

        // Then merge the 2 models together
        return markov.mergeModels(model, newModel)
    }
}

module.exports = markov